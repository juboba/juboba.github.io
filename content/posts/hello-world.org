---
title: "Tips for functions"
date: 2020-11-25T23:37:58+01:00
draft: false
---

* Functions
The following are tips for creating functions in a way that they're easily composable and reusable.

The words *must* and *should* are used as "in order to get the benefit of the
tip", not as an imperative instruction.

** Function names
A function should always have a *verb* in their name since a function implies an
action: Calling it "does something".

#+begin_src js
const getName = user => { return user.name }
const runJobs = jobs => { jobs.forEach(job => job()) }
#+end_src

*** Variable/Constant names
Variables and constants should be *nouns* since they hold data inside.

#+begin_src js
const name = "Juan"
const lastName = "Gosling"
#+end_src

** Make functions do one thing and do it right
Functions that do one thing are easy to test, but even better: They're easy to
reason about.

It can seem at first that this is not easy to do, but doing it helps you
think differently about the code you write.
#+begin_src js
const getUser = (id: number, db: string) => {
    const { active } = JSON.parse(db).users
    const user = active.find(u => u.id === id)

    return user
}
#+end_src

\pagebreak
A simple function like this is doing too much at the same time. Separating it
allows us to see how many things this function is actually doing:
- parsing a JSON string
- accessing a nested structure
- getting a user from of a list

The three of them can fail, so this function is actually super complex!

*** Bringing functions back together
*One way* of bringing functions back together is function composition through
*connecting* functions. Some of these functions are named:
- compose
- pipe
- when (applies a function if the argument satisfies a predicate)
- unless (opposite to when)
- converge (applies functions to the arguments of a function)
- map
- reduce
- filter

And many more. By using these functions you ensure that every time you're repeating
a pattern, you're actually using the same code.

** Don't check function arguments
#+begin_quote
" _Functions should be confident in their input_ and polite on their output"
#+end_quote

#+caption: The getTheme function
#+name: getTheme-function
#+begin_src js -n
function getTheme(id: number | undefined) {
    if (!id)
        return null;
    }

    return database.themes[id];
}
#+end_src
The responsibility of your function must be what's in its name, nothing more.
Adding this little check in line 2 makes the function behave "well" for a case that should not be considered and means that it's design is leaking: We are considering *where* this function will be used which is outside of its scope.

Instead, move the check to the caller:
#+begin_src js
const theme = typeof id === 'number' ? getTheme(id) : null;
#+end_src

This might not be the best way of fighting against ~null~, but it leaves the responsibility of _what_ value to use in case ~id~ is not a valid number to the place where it's going to be used. This means, the caller/parent code might be able to come up with a better solution than:
#+begin_src js
if (theme) {
    // ...
}
#+end_src

** Always return something from the range
#+begin_quote
"Functions should be confident in their input and _polite on their output_"
#+end_quote

This is the counterpart of the previous tip. It means, always return something
of the return type. If the return type is a =User=, then that function should always return a =User=.

Returning ~null~ values means you leave the problem to someone else, namely: the caller. Forcing a chain of null checks along the way.

In the previous [[getTheme-function][example]], the caller of ~getTheme~ needs to check if the returned
value is =null= or not. At the same time, ~getTheme~ itself is checking for an =undefined=.

There are times in which functions are unsafe and could eventually have no valid
value to return. =Maybe= and =Either= are container objects that can help by keeping the type of the
function consistent.

** Dependency injection
When injecting dependencies to a function use "partial application" to make your functions gain context. So instead of doing:
#+begin_src js
const myFunction = (id, myInjectedService) => {
    return myInjectedService.query({ id })
}
#+end_src

Do:
#+begin_src js
const myFunction = myInjectedService => id => {
    return myInjectedService.query({ id })
}
#+end_src

This way, you abstract _function creation_ from _function application_ and you get a free function factory:
#+begin_src js
const myGetUserFunction = myFunction(userService)

myGetUserFunction(13) // { id: 13, name: 'Pepe GÃ³mez'  }
#+end_src

** Prefer expressions
Expressions are fun. They can be almost used anywhere in your code.

\noindent Ever noticed you cannot pass an =if= to a prop in React or 'save' it in a
constant?
#+begin_src js
<Component isOn={if (user.active) { ... }}/>

const something = if (user.active) { ... }
#+end_src
Well, =if= is a *statement*, and these guys expect *expressions*. Expressions
can be placed almost anywhere, and can be used to abstract common repetive
statement-based patterns, like when using the low level =switch=, =for= or =while=.

Ever noticed =function= is an expression? Yes! Because it *returns something*
(this is the key difference between statements and expressions):
#+begin_src js
const someFunc = function() { return 'Yay!' }

<Component onClick={function() { return 'Yay!' }}/>
#+end_src

Statements are fine, but they belong to a _lower level of abstraction_ so we
should try to keep them there, in library code.
They provide a high level of flexibility, but that means lots of moving parts.

For instance, to read a =for= loop
#+begin_src js
for (let i = 0; i < some.length; i = i + 1) {

}
#+end_src

you need to understand 4 things:
#+begin_src js
for (A; B; C) {
    D
}
#+end_src

This is too much complexity to be used repeatedly throughout an application.

# By using expressions you can create reusable code, even across languages: Once
# you know how to implement a =map= function in one language, you know how to
# create it in /all/ of them.

This also means doing more /data flow/ and leave /flow control/ to the lower
level implementations.

** Prefer pure functions
As much as possible, try to separate effects from pure calculations. Pure
functions are easy to unit-test. Even if you don't create the test, creating
functions to be testable can be a good way of keeping coupling low.

Pure functions can be:
- tested without mocks
- safely replaced by other function with the same signature
- memoized if needed

And they're really easy to reason about!

** Distinguish effectful functions
Effects are at the core of any application, since without them the application
makes no sense. They're not going anywhere!
But they don't behave the same as pure functions. They can fail, they can be
asynchronous, they can leave event handlers attached, etc.

So, /as much as possible/, make a distinction between them by not returning
anything from an effectul function. This means, don't reuse the effectful
function to calculate something else.
